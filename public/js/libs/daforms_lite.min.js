/**
 * Вспомогательные методы
 */
var daTools = /** @class */ (function () {
    function daTools() {
    }
    /**
     * Рекурсивно объеденяет 2 объекта в один. При этом значения первого заменяются и дополняются значениями второго
     *
     * выполнив daTools.mergeObjects({a: 1}, {b: 2});
     * получим {a: 1, b: 2}
     *
     * выполнив daTools.mergeObjects({a: 1, {ab: 2}}, {b: 2, {ab: 3, ac: 1}});
     * получим {a: 1, b: 2, {ab: 3, ac: 1}}
     */
    daTools.mergeObjects = function (first, second) {
        for (var key in second) {
            if (!first.hasOwnProperty(key) || first[key] === null)
                first[key] = second[key];
            else if (typeof first[key] === 'object' && first[key].constructor === Object && typeof second[key] === 'object' && second[key].constructor === Object)
                first[key] = daTools.mergeObjects(first[key], second[key]);
            else if (Array.isArray(second[key]) && Array.isArray(first[key])) {
                for (var i = 0; i < second[key].length; i++) {
                    first[key].push(second[key][i]);
                }
            }
            else
                first[key] = second[key];
        }
        return first;
    };
    /**
     * Рекурсивно объеденяет массив объектов в один. При этом значения первого заменяются и дополняются значениями каждого из последующих
     *
     * выполнив daTools.mergeCollection([{a: 1}, {b: 2}, {c: 3}]);
     * получим {a: 1, b: 2, c: 3}
     *
     * выполнив daTools.mergeCollection([{a: 1, {ab: 2}}, {b: 2, {ab: 3, ac: 1}}, {c: 3}]);
     * получим {a: 1, b: 2, c: 3, {ab: 3, ac: 1}}
     */
    daTools.mergeCollection = function (objects) {
        var mergedObject = objects[0];
        for (var i = 1; i < objects.length; i++) {
            mergedObject = this.mergeObjects(mergedObject, objects[i]);
        }
        return mergedObject;
    };
    return daTools;
}());

/**
 * Базовый объект с общими плюшками
 *
 * требует daTools
 */
/// <reference path="../library/jquery.d.ts" />
/// <reference path="./tools.ts" />
var daFormsSimpleObject = /** @class */ (function () {
    /**
     * Устанавливаем конфиг, путем объединения конфига по умолчанию и переданного в конструктор при создании объекта.
     */
    function daFormsSimpleObject(default_config, config) {
        this.errors = [];
        if (default_config && Object.keys(default_config).length > 0 && config && Object.keys(config).length > 0)
            this.config = daTools.mergeObjects(default_config, config);
        else if (default_config && Object.keys(default_config).length > 0)
            this.config = default_config;
        else if (config && Object.keys(config).length > 0)
            this.config = config;
    }
    /**
     * Выводим ошибки, при этом можно добавить финальное сообщение.
     * Возвращает количество ошибок
     */
    daFormsSimpleObject.prototype.showError = function (message) {
        var self = this;
        if (typeof message != 'undefined' && message)
            this.addError(message);
        $.each(self.errors, function (idx, error) {
            console.error(error);
        });
        var errors_count = this.errors.length;
        this.errors = [];
        return errors_count;
    };
    /**
     * Добавляет ошибку
     * Возвращает количество ошибок
     */
    daFormsSimpleObject.prototype.addError = function (message) {
        if (typeof message == 'undefined' || !message) {
            alert('Для метода daFormsSimpleObject::addError необходимо указать параметр message');
        }
        else {
            this.errors.push('daForms: ' + message);
        }
        return this.errors.length;
    };
    /**
     * Выводит сообщение
     */
    daFormsSimpleObject.prototype.showMessage = function (message) {
        if (typeof message == 'undefined' || !message) {
            alert('Для метода daFormsSimpleObject::showMessage необходимо указать параметр message');
        }
        else {
            console.log('daForms: ' + message);
        }
        return true;
    };
    return daFormsSimpleObject;
}());

/**
 * + триггеры на формы после валидации
+ триггер на поле после успешной валидации
+ сообщения о коротком и длинном значении
+ типы ошибок валидации (добавить для коротких и длинных значений)
+ метод для принудительной очистки ошибок
плейсхолдеры
+ дефолтный вывод ошибок
+ полная замена параметров для валидации
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/// <reference path="../library/jquery.d.ts" />
/// <reference path="./simpleObject.ts" />
/// <reference path="./tools.ts" />
/**
 * Класс типа поля
 * Важно не путать тип поля и само поле!!!
 */
var daFormField = /** @class */ (function () {
    function daFormField(name, emptyMessage, errorMessage, preg, minLength, maxLength, tooShortMessage, tooLongMessage, prepareFunction, isDigit) {
        // TODO: возможность переназначения логики метода проверки
        this.name = 'unknown';
        this.emptyMessage = 'Заполните это поле';
        this.errorMessage = 'Не корректное значение';
        this.tooShortMessage = 'Слишком короткое значение';
        this.tooLongMessage = 'Слишком длинное значение';
        this.preg = false;
        this.min = 0;
        this.max = 0;
        this.isDigit = false;
        if (typeof name != 'undefined' && name)
            this.name = name;
        if (typeof emptyMessage != 'undefined' && emptyMessage)
            this.emptyMessage = emptyMessage;
        if (typeof errorMessage != 'undefined' && errorMessage)
            this.errorMessage = errorMessage;
        if (typeof tooShortMessage != 'undefined' && tooShortMessage)
            this.tooShortMessage = tooShortMessage;
        if (typeof tooLongMessage != 'undefined' && tooLongMessage)
            this.tooLongMessage = tooLongMessage;
        if (typeof preg != 'undefined' && preg)
            this.preg = preg;
        if (typeof minLength != 'undefined' && minLength)
            this.min = minLength;
        if (typeof maxLength != 'undefined' && maxLength)
            this.max = maxLength;
        if (typeof isDigit != 'undefined' && isDigit)
            this.isDigit = true;
        if (prepareFunction) {
            if (typeof prepareFunction != 'function' && typeof window[prepareFunction] == 'function')
                prepareFunction = window[prepareFunction];
            if (typeof prepareFunction == 'function')
                this.prepareValue = prepareFunction;
        }
    }
    /**
     * Валидирует отдельное поле по установленным для типа поля правилам
     */
    daFormField.prototype.isValid = function ($field, is_required) {
        if (is_required === void 0) { is_required = false; }
        if (!is_required && typeof $field.getDaOption == 'function' && $field.val() == $field.getDaOption('placeholder')) {
            return {
                name: $field.attr('name'),
                isValid: true,
                errorType: '',
                errorMessage: ''
            };
        }
        var value = this.prepareValue_base($field);
        value = this.prepareValue(value);
        if($field.attr('type') == 'checkbox'){
            if (is_required && !$field.prop('checked')) {
                return {
                    name: $field.attr('name'),
                    isValid: false,
                    errorType: 'empty',
                    errorMessage: this.emptyMessage
                };
            }
        }
        else{
            if (is_required && this.isEmpty(value)) {
                return {
                    name: $field.attr('name'),
                    isValid: false,
                    errorType: 'empty',
                    errorMessage: this.emptyMessage
                };
            }
            if (this.min && this.isTooShort(value)) {
                return {
                    name: $field.attr('name'),
                    isValid: false,
                    errorType: 'too_short',
                    errorMessage: this.tooShortMessage
                };
            }
            if (this.max && this.isTooLong(value)) {
                return {
                    name: $field.attr('name'),
                    isValid: false,
                    errorType: 'too_long',
                    errorMessage: this.tooLongMessage
                };
            }
            if (this.preg && !this.isCorrect(value)) {
                return {
                    name: $field.attr('name'),
                    isValid: false,
                    errorType: 'invalid',
                    errorMessage: this.errorMessage
                };
            }
        }
        return {
            name: $field.attr('name'),
            isValid: true,
            errorType: '',
            errorMessage: ''
        };
    };
    /**
     * Этот метод нужен для того чтоб не допустить обработки сообщений об ошибках как значений поля
     */
    daFormField.prototype.prepareValue_base = function ($field) {
        var value = $field.val();
        if (value == this.emptyMessage || value == this.errorMessage || value == this.tooLongMessage || value == this.tooShortMessage)
            return '';
        if (typeof $field.getDaOption == 'function' && value == $field.getDaOption('placeholder'))
            return '';
        return value;
    };
    /**
     * Этот метод нужен для того чтоб обеспечить возможность подготовки значения перед валидацией
     */
    daFormField.prototype.prepareValue = function (value) {
        return value;
    };
    /**
     * Проверяем значение на пустоту
     */
    daFormField.prototype.isEmpty = function (value, trim) {
        if (trim === void 0) { trim = true; }
        if (!value || !value.length)
            return true;
        if (trim)
            value = value.replace(' ', '');
        if (!value || !value.length)
            return true;
        return false;
    };
    /**
     * Проверяем не короткое ли значение
     */
    daFormField.prototype.isTooShort = function (value, trim) {
        if (trim === void 0) { trim = false; }
        if (!this.isDigit) {
            if (!value || !value.length)
                return true;
            if (trim)
                value = value.replace(' ', '');
            if (value.length < this.min)
                return true;
        }
        else if (+value < this.min)
            return true;
        return false;
    };
    /**
     * Проверяем не длинное ли значение
     */
    daFormField.prototype.isTooLong = function (value, trim) {
        if (trim === void 0) { trim = false; }
        if (!this.isDigit) {
            if (!value || !value.length)
                return true;
            if (trim)
                value = value.replace(' ', '');
            if (value.length > this.max)
                return true;
        }
        else if (+value > this.max)
            return true;
        return false;
    };
    /**
     * Проверяем значение на соответствие регулярному выражению
     */
    daFormField.prototype.isCorrect = function (value) {
        return this.preg.test(value);
    };
    return daFormField;
}());
var daFormValidation = /** @class */ (function (_super) {
    __extends(daFormValidation, _super);
    function daFormValidation(config) {
        var _this = _super.call(this, {
            errorClass: 'error',
            // formClass: 'sendLead',
            validateAllField: false,
            novalidateSelector: '.novalidate, [type="submit"]',
            requiredSelector: '.required',
            debug: false,
            useDefaultActions: {
                on_field_error: true,
                on_form_error: false
            }
        }, config) || this;
        _this.validation_errors = [];
        _this.settings = {
            phone: new daFormField('phone', 'Укажите телефон', 'Не корректный номер', /^[0-9\-\(\)\+\s]{6,30}$/i, 6, 11, '', '', function (value) {
                var value = value.replace(/[\s\+\-\(\)]/gi, '');
                return value;
            }),
            email: new daFormField('email', 'Укажите e-mail', 'Не корректный e-mail', /^[-._a-zA-Z0-9]+@(?:[a-z0-9][-a-z0-9]+\.)+[a-z]{2,6}$/, 7),
            name: new daFormField('name', 'Укажите Ваше имя', 'Не корректно указано имя', false, 2),
            text: new daFormField('', '', '', false, 1),
            textarea: new daFormField('', '', '', false, 1),
            number: new daFormField('', '', '', /^[0-9]*$/, 0),
            select: new daFormField('', 'Выберите значение', '', false, 0),
            unknown: new daFormField()
        };
        if (_this.config.debug)
            _this.showMessage('daFormValidation.constructor complite');
        return _this;
    }
    /**
     * Заменяет все параметры для валидации полей
     */
    daFormValidation.prototype.resetFieldTypes = function (fieldTypes) {
        var new_settings = {};
        var self = this;
        $.each(fieldTypes, function (idx, fieldType) {
            var name = fieldType.name || '';
            var emptyMessage = fieldType.emptyMessage || '';
            var errorMessage = fieldType.errorMessage || '';
            var tooShortMessage = fieldType.tooShortMessage || '';
            var tooLongMessage = fieldType.tooLongMessage || '';
            var preg = fieldType.preg || false;
            var min = fieldType.min || 0;
            var max = fieldType.max || 0;
            var prepareFunction = fieldType.prepareFunction || false;
            var isDigit = fieldType.isDigit || false;
            new_settings[name] = self.addFieldType(name, emptyMessage, errorMessage, preg, min, max, tooShortMessage, tooLongMessage, prepareFunction, isDigit);
        });
        this.settings = new_settings;
        return this.getSettings();
    };
    /**
     * Добавляет параметры для валидации нового типа полей
     */
    daFormValidation.prototype.addFieldType = function (name, emptyMessage, errorMessage, preg, minLength, maxLength, tooShortMessage, tooLongMessage, prepareFunction, isDigit) {
        if (!name) {
            this.showError('Параметр name обязатедльный для метода daFormValidation::addFieldType');
            return false;
        }
        this.settings[name] = new daFormField(name, emptyMessage, errorMessage, preg, minLength, maxLength, tooShortMessage, tooLongMessage, prepareFunction, isDigit);
        if (this.config.debug)
            this.showMessage('daFormValidation.addFieldType complite. Added field ' + name);
        return this.settings[name];
    };
    /**
     * Возвращает текущие параметры валидации полей
     */
    daFormValidation.prototype.getSettings = function () {
        if (this.config.debug)
            this.showMessage('daFormValidation.getSettings complite.');
        return this.settings;
    };
    /**
     * Валидирует всю форму
     * Чтобы не валидировалось определенное поле, ему (полю) нужно добавить атрибут df_novalidate
     */
    daFormValidation.prototype.validateForm = function ($form) {
        this.validation_errors = [];
        if (this.config.validateAllField)
            var $fields = $form.find('input:not(' + this.config.novalidateSelector + '), textarea:not(' + this.config.novalidateSelector + '), select:not(' + this.config.novalidateSelector + ')');
        else
            var $fields = $form.find('input' + this.config.requiredSelector + ', textarea' + this.config.requiredSelector + ', select' + this.config.requiredSelector + '');
            
        var self = this;
        $fields.each(function (idx, field) {
            var $field = $(field);
            // если проверяются все поля, то нужно пропустить пустые не обязательные
            if (self.config.validateAllField && !$field.is(self.config.requiredSelector) && !$field.val())
                return true;
            self.validateField($field);
        });
        if (this.validation_errors.length > 0) {
            $form.trigger('form_validation_error', [this.validation_errors]);
            if (this.config.useDefaultActions.on_form_error) {
                if (this.config.debug)
                    this.showMessage('daFormValidation.validateForm start default error action. Total errors count ' + this.validation_errors.length);
                var errors_text = '';
                var last_idx = this.validation_errors.length - 1;
                $.each(this.validation_errors, function (idx, error) {
                    errors_text += error.errorMessage;
                    if (idx == last_idx)
                        alert(errors_text);
                    else
                        errors_text += "\n";
                });
            }
            if (this.config.debug)
                this.showMessage('daFormValidation.validateForm complite. Total errors count ' + this.validation_errors.length);
        }
        else {
            $form.trigger('form_validation_success');
            if (this.config.debug)
                this.showMessage('daFormValidation.validateForm complite. Success!');
        }
        return this.validation_errors.length == 0;
    };
    /**
     * Валидирует отдельное поле исходя из установленных атрибутов
     */
    daFormValidation.prototype.validateField = function ($field) {
        var field_type = $field.attr('data-type'); // пробуем получить тип поля из data-type
        if (!field_type) {
            field_type = $field.attr('name'); // из name, если data-type нету
            if (!field_type) {
                field_type = $field.attr('type'); // если нету и name, то по типу
                if (!field_type) { // ну и для селектов и текстовых областей у которых нету аттрибута type
                    if ($field.is('textarea'))
                        field_type = 'textarea';
                    else if ($field.is('select'))
                        field_type = 'select';
                }
            }
        }
        if (!field_type)
            field_type = 'unknown'; // ну и если совсем уж натупили с разметкой, то делаем не определенный тип
        // проверим есть ли параметры для валидации
        if (typeof this.settings[field_type] != 'object') {
            this.showError('Не определены правила для валидации поля daFormValidation::settings.' + field_type);
            if (this.config.debug)
                this.showMessage('daFormValidation.validateField error. Field type defined as ' + field_type + ' for field with name ' + $field.attr('name') + '. But not defined validation rulles for this type. Field will be ignored.');
            return {
                name: $field.attr('name'),
                isValid: true,
                errorType: '',
                errorMessage: ''
            };
        }
        // если требуется валидация всех полей, то нужно проверить корректность всех заполненных полей и всех обязательных полей. Если валидация всех полей не требуется, то проверяем только обязательные
        var is_placeholder = typeof $field.getDaOption == 'function' && $field.val() == $field.getDaOption('placeholder');
        var is_required = this.config.validateAllField && $field.val() && !is_placeholder ? true : $field.is(this.config.requiredSelector);
        
        var result = this.settings[field_type].isValid($field, is_required);
        if (!result.isValid)
            this.addValidationError($field, result);
        else
            this.addValidationSuccess($field);
        if (this.config.debug)
            this.showMessage('daFormValidation.validateField complite. Field type defined as ' + field_type + ' for field with name ' + $field.attr('name'));
        return result;
    };
    daFormValidation.prototype.addValidationError = function ($field, result) {
        $field.trigger('validation_error', [result]);
        this.validation_errors.push(result);
        var self = this;
        if (this.config.useDefaultActions.on_field_error) {
            if (this.config.debug)
                this.showMessage('daFormValidation.addValidationError start default error action.');
            var clear = function () {
                $(this).removeClass(self.config.errorClass).val('').unbind('click', clear);
            };
            $field.addClass(this.config.errorClass).val(result.errorMessage).bind('click', clear);
        }
        if (this.config.debug)
            this.showMessage('daFormValidation.addValidationError complite. Total errors count ' + this.validation_errors.length);
        return this.validation_errors.length;
    };
    daFormValidation.prototype.addValidationSuccess = function ($field) {
        $field.trigger('validation_success');
        if (this.config.debug)
            this.showMessage('daFormValidation.addValidationSuccess complite.');
        return true;
    };
    daFormValidation.prototype.clearErrors = function () {
        this.validation_errors = [];
        return true;
    };
    daFormValidation.prototype.getErrors = function () {
        return this.validation_errors;
    };
    return daFormValidation;
}(daFormsSimpleObject));